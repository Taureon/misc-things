<style>
	html, body {
		background-color: black;
		padding: 0px;
		margin: 0px;
		left: 0px;
		top: 0px;
	}
</style>
<canvas id="canvas">Turn on HTML5 Canvas</canvas>
<script>

class Tile {
	constructor (grid, x, y) {
		this.grid = grid;
		this.x = x;
		this.y = y;
		this.nearbyMines = 0;
		this.isMine = false;
		this.isRevealed = false;
		this.isFlagged = false;
	}
	neighbors () {
		let near = this.grid.get3x3(this.x, this.y);
		near.splice(near.indexOf(this), 1); // Remove yourself... NOW...
		return near;
	}
}

class Minesweeper {
	constructor (width, height, mines) {
		this.firstPlay = true;
		this.mines = mines;
		this.width = width;
		this.height = height;
		this.tiles = Array(width * height)
			.fill(i => new Tile(this, i % width, Math.floor(i / width)))
			.map((f, i) => f(i));
	}
	get (x, y) {
		return this.tiles[x + y * this.width];
	}
	get3x3 (x, y) {
		let local = [];
		for (let a = Math.max(0, x - 1); a < Math.min(x + 2, this.width); a++) {
			for (let b = Math.max(0, y - 1); b < Math.min(y + 2, this.height); b++) {
				local.push(this.get(a, b));
			}
		}
		return local;
	}
	generate (x, y) {
		let far = [],
			near = this.get3x3(x, y);
		for (let tile of this.tiles) {
			if (!near.includes(tile)) {
				far.push(tile);
			}
		}

		for (let i = 0; i < this.mines; i++) {
			let index = Math.floor(far.length * Math.random());
			far[index].isMine = true;
			far[index] = far[far.length - 1];
			far.pop();
		}

		for (let tile of this.tiles) {
			for (let neighbor of tile.neighbors()) {
				if (neighbor.isMine) {
					tile.nearbyMines++;
				}
			}
		}
	}
	clear (x, y) {
		let first = this.get(x, y);
		if (first.isRevealed) return;

		let queue = [first],
			toReveal = [];

		while (queue.length) {
			let queueNew = [];
			for (let tile of queue) {
				toReveal.push(tile);
				if (tile.nearbyMines) continue;
				for (let neighbor of tile.neighbors()) {
					if (!(queueNew.includes(neighbor) || toReveal.includes(neighbor))) {
						queueNew.push(neighbor);
					}
				}
			}
			queue = queueNew;
		}

		for (let tile of toReveal) {
			tile.isRevealed = true;
			tile.isFlagged = false;
		}
	}
	play (x, y, wantsFlag) {
		let played = this.get(x, y);
		if (!played) {
			return;
		}
		
		if (!played.isRevealed) {
			if (wantsFlag) {
				played.isFlagged = !played.isFlagged;
				return;
			}

			if (this.firstPlay) {
				this.firstPlay = false;
				this.generate(x, y);
			}

			this.clear(x, y);
			return;
		}

		let neighbors = played.neighbors(),
			counter = 0;

		for (let tile of neighbors) {
			if (!tile.isRevealed) {
				counter++;
			}
		}

		if (played.nearbyMines == counter) {
			for (let tile of neighbors) {
				if (!tile.isRevealed) {
					if (wantsFlag) {
						tile.isFlagged = true;
					} else {
						this.clear(tile.x, tile.y);
					}
				}
			}
		}
	}
}

let canvas = document.getElementById('canvas'),
	ctx = canvas.getContext('2d'),
	halfHeight = 0,
	halfWidth = 0,
	leftOffset = 0,
	topOffset = 0,
	auxMove = false,

	// position of the center of the camera. the center of the grid is also 0, 0
	camX = 0,
	camY = 0,

	// how many screens fit vertically in a tile. 1 => tile height = screen height. uses width if width is lower than height
	camScale = 0.04,

	// i just shoved all the game logic in this class so i dont have to look at it
	minesweeper = new Minesweeper(25, 18, 50),

character = (character, x, y, size) => {
	ctx.strokeText(character, x + size / 2, y + size * 0.56);
	ctx.fillText(character, x + size / 2, y + size * 0.56);
},

render = () => {
	ctx.fillStyle = 'white';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.textBaseline = 'middle';
	ctx.strokeStyle = 'black';
	ctx.textAlign = 'center';
	let size = Math.min(canvas.width, canvas.height) * camScale,
		halfSize = size / 2;
	ctx.font = 'bold ' + (size * 0.75) + 'px Sans-serif';
	ctx.lineWidth = size / 16;

	for (let tile of minesweeper.tiles) {
		let x = (tile.x - minesweeper.height / 2 - camX) * size + halfWidth,
			y = (tile.y - minesweeper.width / 2 - camY) * size + halfHeight;

		// the base of the tile
		ctx.fillStyle = '#404040';
		ctx.fillRect(x - 1, y - 1, size + 1, size + 1);
		ctx.fillStyle = tile.isRevealed ? 'lightgray' : 'gray';
		ctx.fillRect(x + size * 0.1, y + size * 0.1, size * 0.8, size * 0.8);

		// whatever symbol is supposed to be on the tile
		if (!tile.isRevealed) {
			if (tile.isFlagged) {
				ctx.fillStyle = 'red';
				character('âš‘', x, y, size);
			}
		} else if (tile.isMine) {
			character('ðŸ’£', x, y, size);
		} else if (tile.nearbyMines) {
			ctx.fillStyle = ['lightgray', 'blue', 'green', 'red', 'purple', 'black', 'gray', 'maroon', 'turquoise'][tile.nearbyMines];
			character(tile.nearbyMines.toString(), x, y, size);
		}
	}
};

document.onkeypress = event => {
	switch (event.key) {
		case 'w':
		case 'ArrowUp':
			camY -= 1;
			break;
		case 's':
		case 'ArrowDown':
			camY += 1;
			break;
		case 'a':
		case 'ArrowLeft':
			camX -= 1;
			break;
		case 'd':
		case 'ArrowRight':
			camX += 1;
			break;
		default:
			return;
	}
	render();
};
document.onmousemove = event => {
	if (auxMove) {
		let size = Math.min(canvas.width, canvas.height) * camScale;
		camX -= event.movementX / size;
		camY -= event.movementY / size;
		render();
	}
};
document.onmousedown = event => {
	if (event.button == 1) {
		auxMove = true;
	} else {
		let size = Math.min(canvas.width, canvas.height) * camScale,
			x = (event.x - halfWidth - leftOffset) / size + camX + minesweeper.width / 2,
			y = (event.y - halfHeight - topOffset) / size + camY + minesweeper.height / 2;
		console.log(x.toFixed(3), y.toFixed(3), event, {size, camX, camY });
		minesweeper.play(Math.floor(x), Math.floor(y), event.button == 2);
		render();
	}
};
document.onmouseup = event => {
	if (event.button == 1) {
		auxMove = false;
	}
};
document.oncontextmenu = event => event.preventDefault();

document.onwheel = event => {
	let size = Math.min(canvas.width, canvas.height) * camScale,
		camScaleOld = camScale,
		camXOld = camX  // debug only
		camYOld = camY; // debug only
	camScale *= event.deltaY > 0 ? 1.1 : 1 / 1.1;
	camX += ((event.x - halfWidth - leftOffset) / size - camX) * camScale / camScaleOld;
	camY += ((event.y - halfHeight - topOffset) / size - camY) * camScale / camScaleOld;
	console.log(
		'Size:'    .padEnd(8),  size        .toFixed(3).padStart(9),
	  '\nScale:'   .padEnd(9),  camScaleOld .toFixed(3).padStart(9),  camScale .toFixed(3).padStart(9),
	  '\nMouse:'   .padEnd(9),  event.x     .toFixed(3).padStart(9),  event.y  .toFixed(3).padStart(9),
	  '\nOld Cam:' .padEnd(9),  camXOld     .toFixed(3).padStart(9),  camXOld  .toFixed(3).padStart(9),
	  '\nNew Cam:' .padEnd(9),  camX        .toFixed(3).padStart(9),  camX     .toFixed(3).padStart(9));
    render();
};

(window.onresize = () => {
    let w = window.innerWidth,
        h = window.innerHeight,
        scaleW = 16,
        scaleH = 9;
    if (w * scaleH < h * scaleW) {
        canvas.width = w;
        canvas.height = w * scaleH / scaleW;
        canvas.style.top = topOffset = (h - canvas.height) / 2;
        canvas.style.left = leftOffset = 0;
    } else {
        canvas.height = h;
        canvas.width = h * scaleW / scaleH;
        canvas.style.top = topOffset = 0;
        canvas.style.left = leftOffset = (w - canvas.width) / 2;
    }
    halfHeight = canvas.height / 2;
	halfWidth = canvas.width / 2;

    render();
})();
</script>
