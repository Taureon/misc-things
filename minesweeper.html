<style>
	html, body {
		background-color: black;
		padding: 0px;
		margin: 0px;
		left: 0px;
		top: 0px;
	}
	canvas {
		position: relative;
	}
</style>
<canvas id="canvas">Turn on HTML5 Canvas</canvas>
<script>

class Tile {
	constructor (grid, x, y) {
		this.grid = grid;
		this.x = x;
		this.y = y;
		this.nearbyMines = 0;
		this.isMine = false;
		this.isRevealed = false;
		this.isFlagged = false;
	}
	neighbors () {
		let near = this.grid.get3x3(this.x, this.y);
		near.splice(near.indexOf(this), 1); // Remove yourself... NOW...
		return near;
	}
}

class Minesweeper {
	constructor (width, height, mines) {
		this.lost = false;
		this.goingOn = true;
		this.firstPlay = true;
		this.mines = mines;
		this.width = width;
		this.height = height;
		this.tiles = Array(width * height)
			.fill(i => new Tile(this, i % width, Math.floor(i / width)))
			.map((f, i) => f(i));
	}
	get (x, y) {
		return this.tiles[x + y * this.width];
	}
	get3x3 (x, y) {
		let local = [];
		for (let a = Math.max(0, x - 1); a < Math.min(x + 2, this.width); a++) {
			for (let b = Math.max(0, y - 1); b < Math.min(y + 2, this.height); b++) {
				local.push(this.get(a, b));
			}
		}
		return local;
	}
	generate (x, y) {

		// get the area of all tiles that are not near the cursor
		let far = [],
			near = this.get3x3(x, y);
		for (let tile of this.tiles) {
			if (!near.includes(tile)) {
				far.push(tile);
			}
		}

		// put mines in that area
		for (let i = 0; i < Math.min(far.length, this.mines); i++) {
			let index = Math.floor(far.length * Math.random());
			far[index].isMine = true;
			far[index] = far[far.length - 1];
			far.pop();
		}

		// cover up the entire board and count mined neighbors of all tiles
		for (let tile of this.tiles) {
			tile.nearbyMines = 0;
			tile.isRevealed = false;
			tile.isFlagged = false;
			for (let neighbor of tile.neighbors()) {
				if (neighbor.isMine) {
					tile.nearbyMines++;
				}
			}
		}
	}
	clear (x, y) {
		let first = this.get(x, y);
		if (first.isRevealed) return;

		if (first.isMine) {
			first.isRevealed = true;
			this.lost = true;
			this.goingOn = false;
			return;
		}

		let queue = [first],
			toReveal = [];

		while (queue.length) {
			let queueNew = [];
			for (let tile of queue) {
				toReveal.push(tile);
				if (tile.nearbyMines || tile.isRevealed) continue;
				for (let neighbor of tile.neighbors()) {
					if (!(queueNew.includes(neighbor) || toReveal.includes(neighbor))) {
						queueNew.push(neighbor);
					}
				}
			}
			queue = queueNew;
		}

		for (let tile of toReveal) {
			tile.isRevealed = true;
			tile.isFlagged = false;
		}
	}
	checkWin () {}
	play (x, y, wantsFlag) {
		let played = this.get(x, y);
		if (!played) {
			return;
		}
		
		if (!played.isRevealed) {
			if (wantsFlag) {
				played.isFlagged = !played.isFlagged;
				return;
			}

			if (this.firstPlay) {
				this.firstPlay = false;
				this.generate(x, y);
			}

			if (!played.isFlagged) {
				this.clear(x, y);
			}
			return;
		}

		let neighbors = played.neighbors(),
			counter = 0;

		for (let tile of neighbors) {
			if (wantsFlag ? !tile.isRevealed : tile.isFlagged) {
				counter++;
			}
		}

		if (played.nearbyMines == counter) {
			for (let tile of neighbors) {
				if (wantsFlag || !tile.isFlagged) {
					if (wantsFlag && !tile.isRevealed) {
						tile.isFlagged = true;
					} else {
						this.clear(tile.x, tile.y);
					}
				}
			}
		}
	}
}

let canvas = document.getElementById('canvas'),
	ctx = canvas.getContext('2d'),
	halfHeight = 0,
	halfWidth = 0,
	leftOffset = 0,
	topOffset = 0,
	auxMove = false,

	// position of the top-left corner of the camera
	camX = -1,
	camY = -1,

	// how many screens fit vertically in a tile. 1 => tile height = screen height. uses width if width is lower than height
	camScale = 0.04,

	// i just shoved all the game logic in this class so i dont have to look at it
	minesweeper = new Minesweeper(2500, 1500, 500000), //(25, 18, 100),

character = (character, x, y, size) => {
	ctx.strokeText(character, x + size / 2, y + size * 0.56);
	ctx.fillText(character, x + size / 2, y + size * 0.56);
},

render = () => {
	ctx.fillStyle = 'white';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.textBaseline = 'middle';
	ctx.strokeStyle = 'black';
	ctx.textAlign = 'center';
	let size = Math.min(canvas.width, canvas.height) * camScale,
		halfSize = size / 2;
	ctx.font = 'bold ' + (size * 0.75) + 'px Sans-serif';
	ctx.lineWidth = size / 16;

	camX = Math.max(-3.75, Math.min(3.75 + minesweeper.width - canvas.width / size, camX));
	camY = Math.max(-3.75, Math.min(3.75 + minesweeper.height - canvas.height / size, camY));

	for (let tile of minesweeper.tiles) {
		let x = (tile.x - camX) * size,
			y = (tile.y - camY) * size;

		// the base of the tile
		ctx.fillStyle = '#404040';
		ctx.fillRect(x, y, size, size);
		ctx.fillStyle = tile.isRevealed ? tile.isMine ? 'red' : 'lightgray' : (tile.isMine && minesweeper.lost) ? 'darkred' : 'gray';
		ctx.fillRect(x + size * 0.1, y + size * 0.1, size * 0.8, size * 0.8);

		// whatever symbol is supposed to be on the tile
		if (!tile.isRevealed) {
			if (tile.isFlagged) {
				ctx.fillStyle = 'red';
				character('âš‘', x, y, size);
			}
		} else if (tile.isMine) {
			character('ðŸ’£', x, y, size);
		} else if (tile.nearbyMines) {
			ctx.fillStyle = ['lightgray', 'blue', 'green', 'red', 'purple', 'black', 'gray', 'maroon', 'turquoise'][tile.nearbyMines];
			character(tile.nearbyMines.toString(), x, y, size);
		}
	}

	ctx.fillStyle = '#000';
	for (let X = 0; X <= minesweeper.width; X++) {
		let x = (X - camX) * size,
			y = (0 - camY) * size;
		ctx.fillRect(x, y, 1, minesweeper.height * size);
	}
	for (let Y = 0; Y <= minesweeper.height; Y++) {
		let x = (0 - camX) * size,
			y = (Y - camY) * size;
		ctx.fillRect(x, y, minesweeper.width * size, 1);
	}
};

document.onkeypress = event => {
	switch (event.key) {
		case 'w': case 'ArrowUp':
			camY -= 0.05 / camScale;
			break;
		case 's': case 'ArrowDown':
			camY += 0.05 / camScale;
			break;
		case 'a': case 'ArrowLeft':
			camX -= 0.05 / camScale;
			break;
		case 'd': case 'ArrowRight':
			camX += 0.05 / camScale;
			break;
		default:
			return;
	}
	render();
};
document.onmousemove = event => {
	if (auxMove) {
		let size = Math.min(canvas.width, canvas.height) * camScale;
		camX -= event.movementX / size;
		camY -= event.movementY / size;
		render();
	}
};
document.onmousedown = event => {
	if (event.button == 1) {
		auxMove = true;
	} else {
		let size = Math.min(canvas.width, canvas.height) * camScale,
			x = (event.x - leftOffset) / size + camX,
			y = (event.y - topOffset) / size + camY;
		minesweeper.play(Math.floor(x), Math.floor(y), event.button == 2);
		render();
	}
};
document.onmouseup = event => {
	if (event.button == 1) {
		auxMove = false;
	}
};
document.oncontextmenu = event => event.preventDefault();

document.onwheel = event => {
	let oldCenterX = camX + canvas.width * camScale,
		oldCenterY = camY + canvas.height * camScale;
	camScale *= event.deltaY < 0 ? 1.1 : 1 / 1.1;
    render();
};

(window.onresize = () => {
    let w = window.innerWidth,
        h = window.innerHeight,
        scaleW = 16,
        scaleH = 9;
    if (w * scaleH < h * scaleW) {
        canvas.width = w;
        canvas.height = w * scaleH / scaleW;
        canvas.style.top = topOffset = (h - canvas.height) / 2;
        canvas.style.left = leftOffset = 0;
    } else {
        canvas.height = h;
        canvas.width = h * scaleW / scaleH;
        canvas.style.top = topOffset = 0;
        canvas.style.left = leftOffset = (w - canvas.width) / 2;
    }
    halfHeight = canvas.height / 2;
	halfWidth = canvas.width / 2;

    render();
})();
</script>
